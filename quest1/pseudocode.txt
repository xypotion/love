init = whatever

update
- shift screen if needed
- shift hero if needed
- if not shifting (and other stuff) then
  - check for input
	- if direction button pressed then
	  - get target tile & its type
		- if CLEAR then
		  - move hero that direction: shifting=true, set destination tile, set movement countdown ("distance to _"?)
		- ELSE
		  - if collision-type then stop, maybe do sfx (later)
			- else 
			  - if map-move-type then
				- trigger map shift and...
				- move hero far the other direction: shifting=true, set destination tile, set movement countdown

shiftHero
- if not at destination then
  - move character toward destination tile, reduce countdown
- else arrive() (shifting = false, snap to grid, trigger interactions, NOT collisions)

draw = whatever

------------------------------------------------------------------------------------------------------
data notes:

event = {}
event.type = "warp", "item", "scene", "battle", "shop"?, "seal", uhh...
event.collide = true or false/nil
event.sprite? what about animation?
- a good question
event.destination = {wy=#,wx=#,my=#,mx=#} (for warping)
event.item = some kinda name/ID of item. low-key for now..., might end up just being "sprite", esp if items are usually in chests outside of battle

map = {}
map.tiles, map.events, map.mapType (for minimap colors for now)
map.last_arrival_tile = last tile the hero ARRIVED at, for when/if you implement universal fast travel

loading data in the final game: just load EVERYTHING into memory when the game starts?
- yes: items, sprite/character art
- maybe: art, enemies, 
- no: cutscenes

------------------------------------------------------------------------------------------------------
next for "quest":

text boxes

pause on a different key? so space can be main interaction

variable zoom, maybe just a toggle between two modes for now (for testing text and stuff)

scenes! maybe named & loaded from script files
- scrolling text boxes
- sprite acting
- no choices yet

loading many maps at once

a menu?? just show map and inventory for now. don't even want to attempt mouse interaction yet (if at all!?)

test on windows :/ just to see how well it works so far
- may need http://love2d.org/wiki/love.window.getPixelScale

save points; saving & loading with http://love2d.org/wiki/love.filesystem

------------------------------------------------------------------------------------------------------
for later:

mouse interaction... at least try it. menus, battles, maybe regular navigation
- maybe if you keep all interfaces and menus confined to the same grid structure, calculating mouse positions and stuff will be easier!
  - just still picturing on-hover tooltips and stuff, which could have more granular interaction, including
- drag and drop for equipment and party arrangement would be ideal but sounds way hard :/

lol, sound

SCRIPTING for:
- event interaction
- map+event loading (in getMap and when starting game)
- cutscenes
- battles
- enemy AI

name entry screens? lol, no idea what to do there

dynamic water border-laying? just lay mostly-transparent coast tiles on top of flat water? 16~64 different water tiles -> 1~4 water tiles + N coast tiles
- maybe not even full tiles: smaller parts instead
- should be easy to write into sprite batches, and performance will barely suffer